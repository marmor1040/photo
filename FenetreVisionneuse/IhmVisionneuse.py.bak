## -*- coding: latin-1 -*-
#"""
#Created on 5 juin 2011
#
#@author: Bureau
#"""
#
import time,sys,copy
from multiprocessing import Process, Pipe
import threading
from PyQt4 import QtCore,QtGui
from PyQt4.QtGui import QApplication,QImage,QPixmap,QDesktopWidget,QPainter
from PyQt4.QtCore import QString,Qt,QPoint,QSize,QRect,QObject,pyqtSlot
import preferences as PREFERENCES
from IhmDiaporama import FenetreDiaporama
from .Affichage import Affiche
from .ThreadChargement import Charge
import Ecrans

from fen_visionneuse import Ui_Visionneuse as FormClass
from PyQt4.QtGui import QWidget as BaseClass
from PyQt4 import QtGui

class FenetreVisionneuse(BaseClass,FormClass):
    def __init__(self,parent,chargement,sender,Pin,Pout):
        BaseClass.__init__(self,parent)
        self.setupUi(self)
#         self.__num_ecran = 2
        self.__Pin = Pin
        self.__Pout = Pout
        self.__timer = None
        self.__timer_wheel = None
#         self.mode_tri = bModeTri
        self.__redraw = False
        self.__miniature_aff = False
        self.__filtre_aff = False
        self.__num_wheel = 0
        self.__quitter_ok = False
        self.__image = None
        self.obj_signal =  QObject(None)
        self.aide = "F1 : aide\n"+\
                    "F2 : bascule plein ecran / fenetre\n"+\
                    "F3 : bascule ecran 1 / ecran 2\n"+\
                    "<up> ou a : image précédente\n"+\
                    "<down> ou z : image suivante\n"+\
                    "<roue souris> : image précédente/suivante\n"+\
                    "<0> : note 0\n"+\
                    "<1> : note 1\n"+\
                    "<2> : note 2\n"+\
                    "<3> : note 3\n"
        self.__gestion_ecrans = Ecrans.Affichage(self,1,x0=100,y0=100,kw=0.5,kh=0.5,plein_ecran=True)
        self.__gestion_ecrans.affiche()
#         self.__Pin.send('##resize##')
#         self.__Pin.send(self.__num_ecran)
#         x,y,w,h=self.x(),self.y(),self.width(),self.height()
#         self.__Pin.send(x+w-300)
#         self.__Pin.send(y)
#         self.__Pin.send(300)
#         self.__Pin.send(h)
#         self.__miniature_aff = True

        self.__charge = chargement
        QObject.connect(sender,QtCore.SIGNAL("changed(QString,QString)"),self.affichePhoto)
        self.show()
#         self.__Pin.send(self.x)
#         self.__Pin.send(self.y)
#         self.__Pin.send(self.w)
#         self.__Pin.send(self.h)
                
    def deplaceAutreEcran(self,o=None):
        if not o:o=self
        sg = QDesktopWidget().screenGeometry(1)
        if o.x() < sg.x():
            self.move(o.x()+sg.x(),o.y())
        else:
            self.move(o.x()-sg.x(),o.y())
                
##    def run(self):
##        cont = True
##        nom = None
##        self.show()
##        while cont:
##           # try:
##            print 'recv',self.__pipe_out
##            nom = self.__pipe_out.recv()
##            print nom
##            if nom == '##quitter##':
##                self.__charge.stop()
##                cont = False
##                #if self.__ihm.isVisible():
##            elif '##repertoire##' in nom:
##                rep = nom.replace('##repertoire##','')
##                # pour arreter le chargement auto des photos
##                self.__charge.courant = None
##                # changement du repertoire
##                print 'rep:',rep
##                ThreadPhoto.rep_photos = rep
##            elif '##photos##' in nom:
##                liste = eval(nom.replace('##photos##',''))
##                # crÃ©ation de la liste des photos
##                print 'photos :',liste
##                if liste:
##                    self.__charge.initialise(liste)
##            elif '##geometrie##' in nom:
##                taille= eval(nom.replace('##geometrie##',''))
##                self.setGeometry(taille)
##            elif '##affiche##' in nom:
##                if ThreadPhoto.rep_photos:
##                    print 'affiche',nom.replace('##affiche##','').split(';')
##                    nom,etoiles,traite = nom.replace('##affiche##','').split(';')
##                    if self.__etoiles:
##                        self.__etoiles.afficheEtoiles(etoiles,eval(traite))
##                    if not self.__pipe_out.poll():
##                        image = self.__charge.get(nom)
##                        pix = QPixmap.fromImage(image)
##                        self.affiche(pix)
##            elif '##reinitialise##' in nom:
##                self.label.clear()
##                self.__charge.clear()
####            except:
####                print 'erreur', nom
####                while self.__pipe_out.poll():
####                    print self.__pipe_out.recv()
####                print 'sortie'
##        #print 'stop affiche'
##        self.quitter()

    @pyqtSlot(QString,QString)
    def affichePhoto(self,nom=False,etoile=False):
        if nom:
            self.__image = self.__charge.get(str(nom))
        pm = QPixmap.fromImage(self.__image)
        taille = self.size()
        p_larg = taille.width()
        p_haut = taille.height()
        if p_larg != 0 and p_haut != 0 :
            pr = float(p_larg)/float(p_haut)
            ir = float(pm.width())/float(pm.height())
            if ir>pr :
                w = p_larg
                h = int(p_larg/ir)
            else :
                h = p_haut
                w = int(h*ir)
            self.label.setPixmap(pm.scaled(w-2,h-2))
        else:
            print("image vide")
        if etoile: self.lbl_etoiles.setText(etoile)
        else: self.lbl_etoiles.setText("")
            
    def keyPressEvent(self,event):
        #################################################
        # messages envoyés dans le Pipe Pin reçu dans la classe Attente de IhmMiniature
        #################################################
        touche = event.key()
        if touche == Qt.Key_F1:
            QtGui.QMessageBox.warning(self.window(),'Aide',self.aide)
        if touche == Qt.Key_F2:
            self.__gestion_ecrans.pleinEcran()
            self.__gestion_ecrans.affiche()
        elif touche == Qt.Key_F3:
            if self.__gestion_ecrans.changeEcran():
                self.__Pin.send('##change_ecran##')
        elif touche == Qt.Key_Up or touche == PREFERENCES.PREC:
            self.__Pin.send('##up##')
        elif touche == Qt.Key_Down or touche == PREFERENCES.SUIV:
            self.__Pin.send('##down##')
        elif touche == PREFERENCES.ETOILE0:
            self.__Pin.send('##0_Etoile##')
        elif touche == PREFERENCES.ETOILE1:
            self.__Pin.send('##1_Etoile##')
        elif touche == PREFERENCES.ETOILE2:
            self.__Pin.send('##2_Etoiles##')
        elif touche == PREFERENCES.ETOILE3:
            self.__Pin.send('##3_Etoiles##')

    def wheelEvent(self,event):
#        if self.__timer_wheel:
#            self.__num_wheel += 1
#            print self.__num_wheel,'ajout'
#            sys.stdout.flush()
#        else:
#            print 'envoi',self.__num_wheel
#            self.__num_wheel = 0
#            self.__timer_wheel = self.startTimer(1000)
#            self.killTimer(self.__timer_wheel)
        self.__Pin.send(str(event.delta()))
        if event.delta() > 0:
            self.__Pin.send('##up##')
        else:
            self.__Pin.send('##down##')
            
    def mouseMoveEvent(self,event):
        if self.__redraw:
            #print '##redraw##'
            #sys.stdout.flush()
            self.__Pin.send('##redraw##')
            self.__redraw = False
#         if not self.mode_tri:
#             x = event.x()
#             xm = self.width()
#             y = event.y()
#             ym = self.height()
#             if x > xm * 0.8 and y < ym * 0.2:
#                 if not self.__miniature_aff:
#                     self.__Pin.send('##affiche_miniatures##')
#                     self.__Pin.send(self.__num_ecran)
#                     self.__miniature_aff = True
#             else:
#                 self.__Pin.send('##cache_miniatures##')
#                 self.__miniature_aff = False
#             w,h = self.__diaporama.x()+self.__diaporama.width(),self.__diaporama.y()+self.__diaporama.height()
#             if y < h and x < w:
#                 self.__diaporama.show()
#             else:
#                 self.__diaporama.hide()
#             if x < xm * 0.2 and y > ym * 0.8:
#                 if not self.__filtre_aff:
#                     self.__Pin.send('##affiche_filtre##')
#                     self.__Pin.send(self.__num_ecran)
#                     self.__filtre_aff = True
#             else:
#                 self.__Pin.send('##cache_filtre##')
#                 self.__filtre_aff = False
#         if self.__timer:
#             self.killTimer(self.__timer)
#             self.setCursor(Qt.ArrowCursor)
#         self.__timer = self.startTimer(3000)
    
    def timerEvent(self,timer):
        self.setCursor(Qt.BlankCursor)
        
    def closeEvent(self,event):
        # fermeture de la fenetre visionneuse
        if self.__timer:
            pass
            # erreur quand on tue le timer
            # voir si c'est utile en mode tri photo
            #print 'je tue le timer'
            #self.killTimer(self.__timer)
        self.quitter()
      
    def resizeEvent(self,event):
        self.__redraw = True
        rect = self.geometry()
        self.label.setGeometry(0,0,rect.width(),rect.height())
        if self.__image: self.affichePhoto()
        
    def avanceDiaporama(self):
        self.__Pin.send('##down##')
        
    def quitter(self,rm=False):
        if not self.__quitter_ok:
            #print 'fermer visio'
            self.__quitter_ok = True
            self.window().close()
#        self.__Pin.send('##quitter##')
#        self.__Pin.send(rm)
#        self.__Pout.send('##quitter##')
        
def monprint(*obj):
    if False:
        print(obj)
        sys.stdout.flush()

def getDesciptionImage(photo):
    ret = {}
    info = photo._getexif()
    for tag, value in list(info.items()):
        decoded = TAGS.get(tag, tag)
        if decoded in PREFERENCES.INFOS_PHOTO:
            ret[decoded] = value
    return ret

def execute(Pout_mini,Pin_visio):
    app = QApplication([])
    app.setStyle("plastique")
    thread_chargement = Charge()
    thread_affichage = Affiche(thread_chargement,Pout_mini)
    ihm = FenetreVisionneuse(None,thread_chargement,thread_affichage,Pin_visio,Pout_mini)
    thread_chargement.start()
    thread_affichage.start()
    #ihm.show()
    app.exec_()
        
def start(Pout_mini,Pin_visio):
    process = Process(target=execute,args=(Pout_mini,Pin_visio,))
    process.start()
    return process
    
def stop(process):
    time.sleep(3)
    process.terminate()
    #print 'terminate'
    
if __name__ == "__main__":
    app = QApplication([])
    app.setStyle("plastique")
    Pout_visio,Pin_visio = Pipe()
    Pout_mini,Pin_mini = Pipe()
    pipe_fen_photo = start(Pout_mini,Pin_visio,False)
    time.sleep(5)
    pip= Pin_mini
    print('go',pip)
    pip.send('##repertoire##./Photos/')
    print('go')
    pip.send('##photos##["nettoyage_mur_01.JPG","nettoyage_mur_02.JPG","nettoyage_mur_03.JPG"]')
    print('go')
    pip.send('##affiche##nettoyage_mur_01.JPG;False;False')
    print('1')
    time.sleep(5)
    pip.send('##affiche##nettoyage_mur_02.JPG;False;False')
    print('2')
    time.sleep(5)
    pip.send('##affiche##nettoyage_mur_03.JPG;False;False')
    print('3')
    time.sleep(5)
    pip.send('##quitter##')
